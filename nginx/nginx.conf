worker_processes auto;

events {
  worker_connections  65535;
  multi_accept on;
}

http {
  include       mime.types;
  default_type  application/octet-stream;

  sendfile        on;
  tcp_nopush      on;
  tcp_nodelay     on;
  keepalive_timeout  30s;

  # Light log to keep CPU lower
  log_format short '$remote_addr $status $request_time "$request"';
  access_log /var/log/nginx/access.log short;
  error_log  /var/log/nginx/error.log warn;

  server_tokens off;

  # Upstreams
  upstream httpbin { server tf-httpbin:8080; }

  # Rate limiting zone (e.g., 2 req/s)
  limit_req_zone $rate_key zone=rl_zone:10m rate=2r/s;

  # Map for rate limiting key (only apply for rl bucket)
  map $bucket $rate_key {
    rl $binary_remote_addr;
    default "";
  }

  # Map host to bucket
  map $host $bucket {
    default                 ok;
    "~^ok-\d+\."            ok;
    "~^redirect-\d+\."      redirect;
    "~^rl-\d+\."            rl;
    "~^delay(\d+)s-\d+\."   delay;
    "~^big-\d+\."           big;
    "~^err-\d+\."           err;
    "~^waf-\d+\."           waf;
  }

  # Simple “WAF-like” block rules (simulate false-positives/blocks)
  map $args $waf_block {
    default 0;
    "~*(union(\s|%20)+select|select(\s|%20)+from|<script|onerror=)" 1;
  }

  # Extract delay seconds from host for delay bucket
  map $host $delay_sec {
    default 1;
    ~^delay(\d+)s- $1;
  }

  server {
    listen 80 reuseport;

    # Common proxy headers
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_http_version 1.1;
    proxy_set_header Connection "";

    # Bucket routing
    location / {
      set $waf_final 0;

      if ($bucket = waf) { set $waf_final $waf_block; }

      if ($waf_final = 1) { return 403; }

      set $upstream_uri "/get";

      if ($bucket = waf) { set $upstream_uri "/get"; }

      if ($bucket = redirect) { set $upstream_uri "/redirect/3"; }

      if ($bucket = big)      { set $upstream_uri "/bytes/1048576"; }

      if ($bucket = err)      { set $upstream_uri "/status/500"; }

      if ($bucket = rl) {
        set $upstream_uri "/status/200";
      }

      if ($bucket ~* "^delay") { set $upstream_uri "/delay/$delay_sec"; }

      # Apply rate limit only for rl bucket
      limit_req zone=rl_zone burst=5 nodelay;

      proxy_pass http://httpbin$upstream_uri;
    }
  }

  server {
    listen 443 ssl http2 reuseport;

    ssl_certificate     /etc/nginx/certs/wildcard.crt;
    ssl_certificate_key /etc/nginx/certs/wildcard.key;
    ssl_session_cache   shared:SSL:50m;
    ssl_session_timeout 1d;
    ssl_protocols       TLSv1.2 TLSv1.3;

    # same headers & maps as :80 server
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_http_version 1.1;
    proxy_set_header Connection "";

    # reuse $bucket/$delay_sec/$waf_block logic
    location / {
      set $waf_final 0;
      if ($bucket = waf) { set $waf_final $waf_block; }
      if ($waf_final = 1) { return 403; }

      set $upstream_uri "/get";
      if ($bucket = waf)      { set $upstream_uri "/get"; }
      if ($bucket = redirect) { set $upstream_uri "/redirect/3"; }
      if ($bucket = big)      { set $upstream_uri "/bytes/1048576"; }
      if ($bucket = err)      { set $upstream_uri "/status/500"; }
      if ($bucket = rl)       { set $upstream_uri "/status/200"; }
      if ($bucket ~* "^delay"){ set $upstream_uri "/delay/$delay_sec"; }

      # rate limit still applies to rl bucket due to $rate_key map
      limit_req zone=rl_zone burst=5 nodelay;

      proxy_pass http://httpbin$upstream_uri;
    }
  }
}